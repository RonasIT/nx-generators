import { ClassConstructor, instanceToPlain, plainToInstance } from 'class-transformer';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import { useCallback, useRef } from 'react';
import { FilteringSearchParams } from '../types';

interface FilteringSearchParamsConfig<TParams> {
  searchParamsConstructor: ClassConstructor<TParams>;
}

export const useFilteringSearchParams = <TParams extends FilteringSearchParams>({
  searchParamsConstructor
}: FilteringSearchParamsConfig<TParams>): typeof result => {
  const initialParams = useRef<TParams | null>(null);
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();

  const getSearchParams = useCallback((): TParams => {
    const initialParams = {} as Record<string, any>;
    searchParams.forEach((value, key) => {
      try {
        initialParams[key] = JSON.parse(value);
      } catch {
        initialParams[key] = value;
      }
    });

    return plainToInstance(searchParamsConstructor, initialParams, {
      excludeExtraneousValues: true,
      exposeUnsetFields: false
    });
  }, [searchParams]);

  const setSearchParams = useCallback(
    (params: TParams): void => {
      const newSearchParams = new URLSearchParams();
      const plainParams = instanceToPlain(params, { exposeUnsetFields: false });

      Object.keys(plainParams).forEach((field) => {
        const value = plainParams[field];

        if (value !== null && value !== undefined && !(Array.isArray(value) && value.length === 0)) {
          newSearchParams.set(field, JSON.stringify(value));
        }
      });

      const newParamsString = newSearchParams.toString();
      router.replace(`${pathname}${newParamsString ? `?${newParamsString}` : ''}`);
    },
    [router.replace, pathname],
  );

  initialParams.current = getSearchParams();

  const result = {
    initialSearchParams: initialParams.current,
    setSearchParams
  };

  return result;
};
